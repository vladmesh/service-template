# Architecture & Design

This document describes how the principles in `MANIFESTO.md` are implemented technically.

## The "Spec-First" Flow

The heart of the framework is the `shared/spec/` directory. This is the single source of truth for the data model and API surface.

```mermaid
graph TD
    Spec[shared/spec/*.yaml] -->|make generate-from-spec| GenCode[shared/generated/]
    GenCode -->|Imported by| Services[Services]
    Services -->|Implemented in| Docker[Docker Containers]
```

1.  **Define:** You edit `shared/spec/models.yaml`{% if 'tg_bot' in modules or 'notifications' in modules %} or `shared/spec/events.yaml`{% endif %}.
2.  **Generate:** Run `make generate-from-spec`. This produces Pydantic models{% if 'backend' in modules %} and FastAPI router stubs{% endif %} in `shared/generated/`.
3.  **Implement:** Services import these generated assets. You only write the business logic to satisfy the interfaces.

## Service Modules

The project is a collection of modular services defined in `services.yml`.

- **Definition:** A service is simply an entry in `services.yml` with a `name`, `type`, and `description`.
- **Scaffolding:** The `make sync-services` command ensures that for every entry in `services.yml`, a corresponding directory exists in `services/` with the correct boilerplate.
- **Isolation:** Each service is its own Docker container. They communicate only via defined APIs or shared infrastructure (DB{% if 'tg_bot' in modules or 'notifications' in modules %}, Queue{% endif %}).

### Service Types

{% if 'backend' in modules -%}
- `python-fastapi`: HTTP API service using FastAPI with uvicorn (exposes port 8000).
{% endif -%}
{% if 'tg_bot' in modules or 'notifications' in modules -%}
- `python-faststream`: Event-driven worker using FastStream (no HTTP, consumes from message broker).
{% endif -%}
{% if 'frontend' in modules -%}
- `node`: Node.js service (exposes port 4321).
{% endif -%}
- `default`: Generic container placeholder.

### Compose Options

Services can specify `depends_on` and `profiles` in `services.yml` to customize Docker Compose behavior.

## Containerization Strategy

**Rule:** Nothing runs on the host machine except `docker`, `make`, and `git`.

- **Tooling Container:** We use a dedicated `tooling` service in `docker-compose` to run administrative tasks ({% if 'backend' in modules %}migrations, {% endif %}linting, scaffolding). This ensures all developers and agents use the exact same versions of tools.
- **Service Containers:** Each service has its own `Dockerfile` generated from a template.

## Directory Structure

- `infra/`: Docker Compose files and infrastructure config.
- `services/`: Source code for individual microservices.
{% if 'backend' in modules -%}
  - `backend/`: FastAPI REST API with PostgreSQL.
{% endif -%}
{% if 'tg_bot' in modules -%}
  - `tg_bot/`: Telegram bot (FastStream worker).
{% endif -%}
{% if 'notifications' in modules -%}
  - `notifications_worker/`: Notification service (email, telegram).
{% endif -%}
{% if 'frontend' in modules -%}
  - `frontend/`: Node.js frontend.
{% endif %}
- `shared/`:
    - `spec/`: YAML specifications (Source of Truth).
    - `generated/`: Auto-generated code (Do Not Edit).
- `templates/`: Jinja2 templates for scaffolding new services.

## Infrastructure Components

{% if 'backend' in modules -%}
- **PostgreSQL:** Primary database for persistent storage.
{% endif -%}
{% if 'tg_bot' in modules or 'notifications' in modules -%}
- **Redis:** Message broker for async event processing.
{% endif -%}
{% if 'backend' in modules and ('tg_bot' in modules or 'notifications' in modules) %}

## Unified Handlers

The framework supports **unified handlers** — operations that work over multiple transports.

### Operation Types

| Type | Config | Behavior |
|------|--------|----------|
| **Query** | `rest:` only | Synchronous read, no side effects |
| **Command** | `rest:` + `events:` | REST returns result, event published async |
| **Background** | `events:` only | No HTTP endpoint, event-driven only |

### Example: Dual-Transport Operation

```yaml
# services/backend/spec/users.yaml
operations:
  create_user:
    input: UserCreate
    output: UserRead
    rest:
      method: POST
      status: 201
    events:
      publish_on_success: user_registered  # Event published after success
```

This generates:
- REST endpoint that calls controller and publishes event after success
- Event adapter in subscriber services that handles `user_registered`
- Unified protocol with all controller methods
{% endif %}

## Deployment

This project supports two deployment modes:

### 1. Manual (Push to main)
Push to `main` branch triggers full CI/CD:
- Build images → Push to GHCR → Deploy to server

### 2. Orchestrated (workflow_dispatch)
External orchestrator can trigger deployment via GitHub API:
```bash
curl -X POST \
  -H "Authorization: Bearer $GITHUB_TOKEN" \
  -H "Accept: application/vnd.github.v3+json" \
  https://api.github.com/repos/OWNER/REPO/actions/workflows/deploy.yml/dispatches \
  -d '{"ref":"main","inputs":{"deploy_host":"1.2.3.4","image_tag":"latest"}}'
```

Required repository secrets:
- `DEPLOY_USER` - SSH username (usually "root")
- `DEPLOY_SSH_KEY` - SSH private key
- `DEPLOY_PROJECT_PATH` - Path on server (e.g., `/opt/services/myapp`)
- `APP_SECRET_KEY` - Application secret
{% if 'backend' in modules %}
- `POSTGRES_PASSWORD` - Database password
{% endif %}
