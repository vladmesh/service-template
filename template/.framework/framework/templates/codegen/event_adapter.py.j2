{#
Template for generating event adapter with unified controller pattern.
Generates FastStream subscriber registration that delegates to ControllerProtocol.
Replaces event_handlers.py.j2 in the unified handlers architecture.
#}
# AUTO-GENERATED BY SERVICE-TEMPLATE - DO NOT EDIT
"""
Event adapter for {{ service_name }} service.

Registers FastStream subscribers that delegate to controller protocols.
"""
from __future__ import annotations

from collections.abc import Callable
from contextlib import AbstractAsyncContextManager
from typing import TYPE_CHECKING

from faststream.redis import RedisBroker
from sqlalchemy.ext.asyncio import AsyncSession

{% if imports %}
from shared.generated.schemas import (
{% for model in imports | sort %}
    {{ model }},
{% endfor %}
)
{% endif %}
{% for domain in domains %}
from .protocols import {{ domain.protocol_name }}
{% endfor %}

if TYPE_CHECKING:
    pass


def create_event_adapter(
    broker: RedisBroker,
    get_session: Callable[[], AbstractAsyncContextManager[AsyncSession]],
{% for domain in domains %}
    get_{{ domain.name }}_controller: Callable[[], {{ domain.protocol_name }}],
{% endfor %}
) -> None:
    """Register event handlers with the broker.
    
    Args:
        broker: FastStream Redis broker instance.
        get_session: Factory that returns async context manager for DB session.
{% for domain in domains %}
        get_{{ domain.name }}_controller: Factory for {{ domain.name }} controller.
{% endfor %}
    """
{% for domain in domains %}
{% for handler in domain.handlers %}
{% if handler.subscribe_channel %}

    @broker.subscriber("{{ handler.subscribe_channel }}")
    async def handle_{{ handler.name }}(event: {{ handler.message_model }}) -> None:
        """Handle {{ handler.subscribe_channel }} events."""
        async with get_session() as session:
            controller = get_{{ domain.name }}_controller()
            try:
{% if handler.publish_on_success_channel %}
                result = await controller.{{ handler.name }}(session, payload=event)
                await session.commit()
                await broker.publish(result, "{{ handler.publish_on_success_channel }}")
{% else %}
                await controller.{{ handler.name }}(session, payload=event)
                await session.commit()
{% endif %}
            except Exception as e:
                await session.rollback()
{% if handler.publish_on_error_channel %}
                await broker.publish(
                    {"error": str(e), "original_event": event.model_dump() if hasattr(event, "model_dump") else event},
                    "{{ handler.publish_on_error_channel }}",
                )
{% endif %}
                raise
{% endif %}
{% endfor %}
{% endfor %}

