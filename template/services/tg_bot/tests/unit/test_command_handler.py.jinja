"""Unit tests for command handler with direct Redis publishing."""

from __future__ import annotations

from typing import Final
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

TEST_TELEGRAM_USER_ID: Final[int] = 123456789


@pytest.fixture
def mock_broker() -> MagicMock:
    """Mock the broker for testing."""
    with patch("services.tg_bot.src.main.broker") as mock:
        mock.connect = AsyncMock()
        mock.close = AsyncMock()
        yield mock


@pytest.fixture
def mock_publish() -> AsyncMock:
    """Mock the publish function."""
    with patch("services.tg_bot.src.main.publish_command_received") as mock:
        mock.return_value = None
        yield mock


@pytest.fixture
def mock_update() -> MagicMock:
    """Create a mock Telegram Update object."""
    update = MagicMock()
    update.effective_user = MagicMock()
    update.effective_user.id = TEST_TELEGRAM_USER_ID
    update.message = MagicMock()
    update.message.text = "/command test"
    update.message.reply_text = AsyncMock()
    return update


@pytest.fixture
def mock_context() -> MagicMock:
    """Create a mock Context object."""
    context = MagicMock()
    context.args = ["arg1", "arg2"]
    return context


@pytest.mark.asyncio
async def test_handle_command_publishes_event(
    mock_publish: AsyncMock,
    mock_broker: MagicMock,
    mock_update: MagicMock,
    mock_context: MagicMock,
) -> None:
    """Test that handle_command publishes event to Redis."""
    from services.tg_bot.src.main import handle_command

    await handle_command(mock_update, mock_context)

    mock_publish.assert_awaited_once()
    published_event = mock_publish.await_args[0][0]

    assert published_event.command == "/command test"
    assert published_event.args == ["arg1", "arg2"]
    assert published_event.user_id == TEST_TELEGRAM_USER_ID
    assert published_event.timestamp is not None

    mock_update.message.reply_text.assert_awaited_once_with("Command published!")


@pytest.mark.asyncio
async def test_handle_command_handles_publish_failure(
    mock_publish: AsyncMock,
    mock_broker: MagicMock,
    mock_update: MagicMock,
    mock_context: MagicMock,
) -> None:
    """Test graceful handling of publish failures."""
    from services.tg_bot.src.main import handle_command

    mock_publish.side_effect = Exception("Redis connection failed")

    await handle_command(mock_update, mock_context)

    mock_update.message.reply_text.assert_awaited_once_with("Failed to send command.")


@pytest.mark.asyncio
async def test_handle_command_skips_without_user(
    mock_publish: AsyncMock,
    mock_broker: MagicMock,
    mock_context: MagicMock,
) -> None:
    """Test that handler skips if no user is present."""
    from services.tg_bot.src.main import handle_command

    update = MagicMock()
    update.effective_user = None
    update.message = MagicMock()

    await handle_command(update, mock_context)

    mock_publish.assert_not_awaited()


@pytest.mark.asyncio
async def test_handle_command_skips_without_message(
    mock_publish: AsyncMock,
    mock_broker: MagicMock,
    mock_context: MagicMock,
) -> None:
    """Test that handler skips if no message is present."""
    from services.tg_bot.src.main import handle_command

    update = MagicMock()
    update.effective_user = MagicMock()
    update.effective_user.id = 123
    update.message = None

    await handle_command(update, mock_context)

    mock_publish.assert_not_awaited()


@pytest.mark.asyncio
async def test_post_init_connects_broker(mock_broker: MagicMock) -> None:
    """Test that post_init connects the broker."""
    from services.tg_bot.src.main import post_init

    app = MagicMock()
    await post_init(app)

    mock_broker.connect.assert_awaited_once()


@pytest.mark.asyncio
async def test_post_shutdown_closes_broker(mock_broker: MagicMock) -> None:
    """Test that post_shutdown closes the broker."""
    from services.tg_bot.src.main import post_shutdown

    app = MagicMock()
    await post_shutdown(app)

    mock_broker.close.assert_awaited_once()

{% if 'backend' in modules %}

class TestSyncUserWithBackend:
    """Tests for _sync_user_with_backend function.

    Note: Retry logic is now handled by the generated BackendClient.
    These tests verify the integration between _sync_user_with_backend
    and BackendClient, not the retry implementation details.
    """

    @pytest.mark.asyncio
    async def test_sync_user_created(self) -> None:
        """Test that new user creation returns True."""
        from unittest.mock import AsyncMock

        from shared.generated.schemas import UserRead

        mock_user = UserRead(id=1, telegram_id=TEST_TELEGRAM_USER_ID, is_admin=False)

        with patch("services.tg_bot.src.main.BackendClient") as mock_client_class:
            mock_client = AsyncMock()
            mock_client.create_user = AsyncMock(return_value=mock_user)
            mock_client.__aenter__ = AsyncMock(return_value=mock_client)
            mock_client.__aexit__ = AsyncMock(return_value=None)
            mock_client_class.return_value = mock_client

            from services.tg_bot.src.main import _sync_user_with_backend

            result = await _sync_user_with_backend(TEST_TELEGRAM_USER_ID)
            assert result is True

    @pytest.mark.asyncio
    async def test_sync_user_already_exists(self) -> None:
        """Test that 409 CONFLICT returns False (user exists)."""
        from http import HTTPStatus
        from unittest.mock import AsyncMock

        import httpx

        # Create mock response for 409 status
        mock_response = MagicMock()
        mock_response.status_code = HTTPStatus.CONFLICT
        mock_response.text = "User already exists"

        with patch("services.tg_bot.src.main.BackendClient") as mock_client_class:
            mock_client = AsyncMock()
            mock_client.create_user = AsyncMock(
                side_effect=httpx.HTTPStatusError(
                    "Conflict",
                    request=MagicMock(),
                    response=mock_response,
                )
            )
            mock_client.__aenter__ = AsyncMock(return_value=mock_client)
            mock_client.__aexit__ = AsyncMock(return_value=None)
            mock_client_class.return_value = mock_client

            from services.tg_bot.src.main import _sync_user_with_backend

            result = await _sync_user_with_backend(TEST_TELEGRAM_USER_ID)
            assert result is False

    @pytest.mark.asyncio
    async def test_sync_user_http_error(self) -> None:
        """Test that HTTPError returns None (handled gracefully)."""
        from unittest.mock import AsyncMock

        import httpx

        with patch("services.tg_bot.src.main.BackendClient") as mock_client_class:
            mock_client = AsyncMock()
            mock_client.create_user = AsyncMock(
                side_effect=httpx.HTTPError("Connection failed after retries")
            )
            mock_client.__aenter__ = AsyncMock(return_value=mock_client)
            mock_client.__aexit__ = AsyncMock(return_value=None)
            mock_client_class.return_value = mock_client

            from services.tg_bot.src.main import _sync_user_with_backend

            result = await _sync_user_with_backend(TEST_TELEGRAM_USER_ID)
            assert result is None

    @pytest.mark.asyncio
    async def test_sync_user_connect_error(self) -> None:
        """Test that ConnectError returns None (after client exhausts retries)."""
        from unittest.mock import AsyncMock

        import httpx

        with patch("services.tg_bot.src.main.BackendClient") as mock_client_class:
            mock_client = AsyncMock()
            mock_client.create_user = AsyncMock(
                side_effect=httpx.ConnectError("Backend unavailable after retries")
            )
            mock_client.__aenter__ = AsyncMock(return_value=mock_client)
            mock_client.__aexit__ = AsyncMock(return_value=None)
            mock_client_class.return_value = mock_client

            from services.tg_bot.src.main import _sync_user_with_backend

            result = await _sync_user_with_backend(TEST_TELEGRAM_USER_ID)
            assert result is None

    @pytest.mark.asyncio
    async def test_sync_user_4xx_error(self) -> None:
        """Test that 4xx client errors return None (no retry by client)."""
        from http import HTTPStatus
        from unittest.mock import AsyncMock

        import httpx

        mock_response = MagicMock()
        mock_response.status_code = HTTPStatus.BAD_REQUEST
        mock_response.text = "Bad Request"

        with patch("services.tg_bot.src.main.BackendClient") as mock_client_class:
            mock_client = AsyncMock()
            mock_client.create_user = AsyncMock(
                side_effect=httpx.HTTPStatusError(
                    "Bad Request",
                    request=MagicMock(),
                    response=mock_response,
                )
            )
            mock_client.__aenter__ = AsyncMock(return_value=mock_client)
            mock_client.__aexit__ = AsyncMock(return_value=None)
            mock_client_class.return_value = mock_client

            from services.tg_bot.src.main import _sync_user_with_backend

            result = await _sync_user_with_backend(TEST_TELEGRAM_USER_ID)
            assert result is None


class TestHandleStart:
    """Tests for handle_start function."""

    @pytest.fixture
    def mock_sync_user(self) -> AsyncMock:
        """Mock _sync_user_with_backend."""
        with patch("services.tg_bot.src.main._sync_user_with_backend") as mock:
            yield mock

    @pytest.mark.asyncio
    async def test_handle_start_new_user(self, mock_sync_user: AsyncMock) -> None:
        """Test greeting for new user."""
        from services.tg_bot.src.main import DEFAULT_GREETING, handle_start

        mock_sync_user.return_value = True

        update = MagicMock()
        update.effective_user = MagicMock()
        update.effective_user.id = TEST_TELEGRAM_USER_ID
        update.effective_user.first_name = "John"
        update.message = MagicMock()
        update.message.reply_text = AsyncMock()

        context = MagicMock()

        await handle_start(update, context)

        update.message.reply_text.assert_awaited_once()
        call_args = update.message.reply_text.await_args[0][0]
        assert DEFAULT_GREETING in call_args
        assert "John" in call_args

    @pytest.mark.asyncio
    async def test_handle_start_returning_user(self, mock_sync_user: AsyncMock) -> None:
        """Test greeting for returning user."""
        from services.tg_bot.src.main import WELCOME_BACK_GREETING, handle_start

        mock_sync_user.return_value = False

        update = MagicMock()
        update.effective_user = MagicMock()
        update.effective_user.id = TEST_TELEGRAM_USER_ID
        update.effective_user.first_name = "Jane"
        update.message = MagicMock()
        update.message.reply_text = AsyncMock()

        context = MagicMock()

        await handle_start(update, context)

        update.message.reply_text.assert_awaited_once()
        call_args = update.message.reply_text.await_args[0][0]
        assert WELCOME_BACK_GREETING in call_args

    @pytest.mark.asyncio
    async def test_handle_start_sync_error(self, mock_sync_user: AsyncMock) -> None:
        """Test error message when sync fails."""
        from services.tg_bot.src.main import REGISTRATION_ERROR, handle_start

        mock_sync_user.return_value = None

        update = MagicMock()
        update.effective_user = MagicMock()
        update.effective_user.id = TEST_TELEGRAM_USER_ID
        update.effective_user.first_name = "Bob"
        update.message = MagicMock()
        update.message.reply_text = AsyncMock()

        context = MagicMock()

        await handle_start(update, context)

        update.message.reply_text.assert_awaited_once_with(REGISTRATION_ERROR)

    @pytest.mark.asyncio
    async def test_handle_start_no_user(self, mock_sync_user: AsyncMock) -> None:
        """Test that handler skips if no user."""
        from services.tg_bot.src.main import handle_start

        update = MagicMock()
        update.effective_user = None
        update.message = MagicMock()

        context = MagicMock()

        await handle_start(update, context)

        mock_sync_user.assert_not_awaited()
{% else %}

class TestHandleStart:
    """Tests for handle_start function (standalone mode, no backend)."""

    @pytest.mark.asyncio
    async def test_handle_start_greets_user(self) -> None:
        """Test greeting for user in standalone mode."""
        from services.tg_bot.src.main import DEFAULT_GREETING, handle_start

        update = MagicMock()
        update.effective_user = MagicMock()
        update.effective_user.id = TEST_TELEGRAM_USER_ID
        update.effective_user.first_name = "John"
        update.message = MagicMock()
        update.message.reply_text = AsyncMock()

        context = MagicMock()

        await handle_start(update, context)

        update.message.reply_text.assert_awaited_once()
        call_args = update.message.reply_text.await_args[0][0]
        assert DEFAULT_GREETING in call_args
        assert "John" in call_args

    @pytest.mark.asyncio
    async def test_handle_start_no_user(self) -> None:
        """Test that handler skips if no user."""
        from services.tg_bot.src.main import handle_start

        update = MagicMock()
        update.effective_user = None
        update.message = MagicMock()
        update.message.reply_text = AsyncMock()

        context = MagicMock()

        await handle_start(update, context)

        update.message.reply_text.assert_not_awaited()
{% endif %}
