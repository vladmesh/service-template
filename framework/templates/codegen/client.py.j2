# AUTO-GENERATED BY SERVICE-TEMPLATE - DO NOT EDIT
"""
Typed HTTP client for {{ provider }} service.

Features:
- Async context manager for connection lifecycle
- Automatic retry with exponential backoff on transient errors
- Configurable timeout and retry parameters
"""
from __future__ import annotations

import asyncio
import logging
import os
from http import HTTPStatus
from typing import Any

import httpx

{% if imports %}
from shared.generated.schemas import (
    {% for model in imports|sort %}
    {{ model }},
    {% endfor %}
)
{% endif %}

LOGGER = logging.getLogger(__name__)


class {{ provider_capitalized }}Client:
    """Async HTTP client for {{ provider }} service API.
    
    Features built-in retry with exponential backoff for transient errors:
    - Retries on httpx.ConnectError (service unavailable)
    - Retries on 5xx status codes (server errors)
    - No retry on 4xx client errors (fails immediately)
    
    Usage:
        async with {{ provider_capitalized }}Client() as client:
            result = await client.create_user(payload)
        
        # With custom retry settings:
        async with {{ provider_capitalized }}Client(max_retries=5, initial_delay=0.5) as client:
            result = await client.get_user(user_id=123)
    """
    
    def __init__(
        self,
        base_url: str | None = None,
        timeout: float = 10.0,
        max_retries: int = 3,
        initial_delay: float = 1.0,
    ) -> None:
        """Initialize client.
        
        Args:
            base_url: Base URL for the service. Defaults to {{ provider_upper }}_API_URL env var.
            timeout: Request timeout in seconds.
            max_retries: Maximum number of retry attempts for transient errors.
            initial_delay: Initial delay in seconds, doubles each retry (exponential backoff).
        """
        self.base_url = base_url or os.getenv("{{ provider_upper }}_API_URL", "")
        if not self.base_url:
            raise ValueError(
                "{{ provider_capitalized }}Client requires base_url or "
                "{{ provider_upper }}_API_URL environment variable"
            )
        self.timeout = timeout
        self.max_retries = max_retries
        self.initial_delay = initial_delay
        self._client: httpx.AsyncClient | None = None

    async def __aenter__(self) -> "{{ provider_capitalized }}Client":
        """Enter async context manager."""
        self._client = httpx.AsyncClient(
            base_url=self.base_url,
            timeout=self.timeout,
        )
        return self

    async def __aexit__(self, *args: Any) -> None:
        """Exit async context manager."""
        if self._client:
            await self._client.aclose()
            self._client = None

    def _ensure_client(self) -> httpx.AsyncClient:
        """Ensure client is initialized."""
        if self._client is None:
            raise RuntimeError(
                "{{ provider_capitalized }}Client must be used as async context manager: "
                "async with {{ provider_capitalized }}Client() as client: ..."
            )
        return self._client

    async def _request_with_retry(
        self,
        method: str,
        path: str,
        **kwargs: Any,
    ) -> httpx.Response:
        """Execute HTTP request with retry logic for transient errors.
        
        Implements exponential backoff:
        - Retries on httpx.ConnectError (service unavailable)
        - Retries on 5xx status codes (server errors)
        - No retry on 4xx client errors (fails immediately)
        
        Args:
            method: HTTP method (get, post, put, delete, etc.)
            path: Request path
            **kwargs: Additional arguments passed to httpx request
            
        Returns:
            httpx.Response on success
            
        Raises:
            httpx.HTTPStatusError: On 4xx errors (no retry) or after all retries exhausted
            httpx.ConnectError: After all retries exhausted
        """
        client = self._ensure_client()
        delay = self.initial_delay
        last_exception: Exception | None = None
        
        for attempt in range(self.max_retries):
            try:
                response = await getattr(client, method)(path, **kwargs)
                response.raise_for_status()
                return response
                
            except httpx.HTTPStatusError as e:
                status = e.response.status_code
                
                # 4xx client errors - don't retry, fail immediately
                if HTTPStatus.BAD_REQUEST <= status < HTTPStatus.INTERNAL_SERVER_ERROR:
                    raise
                
                # 5xx server errors - retry with backoff
                last_exception = e
                if attempt < self.max_retries - 1:
                    LOGGER.warning(
                        "%s returned %s (attempt %d/%d), retrying in %.1fs...",
                        self.base_url,
                        status,
                        attempt + 1,
                        self.max_retries,
                        delay,
                    )
                    await asyncio.sleep(delay)
                    delay *= 2
                    
            except httpx.ConnectError as e:
                last_exception = e
                if attempt < self.max_retries - 1:
                    LOGGER.warning(
                        "%s unavailable (attempt %d/%d), retrying in %.1fs...",
                        self.base_url,
                        attempt + 1,
                        self.max_retries,
                        delay,
                    )
                    await asyncio.sleep(delay)
                    delay *= 2
        
        # All retries exhausted
        LOGGER.error(
            "Request to %s failed after %d attempts",
            self.base_url,
            self.max_retries,
        )
        if last_exception:
            raise last_exception
        raise RuntimeError("Unexpected retry loop exit")

    {% for domain in domains %}
    # --- {{ domain.name }} operations ---
    {% for op in domain.operations %}

    async def {{ op.name }}(
        self,
        {% for param in op.params %}
        {{ param.name }}: {{ param.type }},
        {% endfor %}
        {% if op.input_model %}
        payload: {{ op.input_model }},
        {% endif %}
    ) -> {{ op.return_type }}:
        """Call {{ op.name }} on {{ provider }} service."""
        {% if op.params %}
        path = "{{ domain.prefix }}{{ op.path }}".format(
            {% for param in op.params %}
            {{ param.name }}={{ param.name }},
            {% endfor %}
        )
        {% else %}
        path = "{{ domain.prefix }}{{ op.path }}"
        {% endif %}
        
        response = await self._request_with_retry(
            "{{ op.http_method }}",
            path,
            {% if op.input_model %}
            json=payload.model_dump(mode="json"),
            {% endif %}
        )
        {% if op.output_model %}
        return {{ op.output_model }}.model_validate(response.json())
        {% endif %}
    {% endfor %}
    {% endfor %}
