##############################################################################
# THIS FILE IS GENERATED BY THE FRAMEWORK. DO NOT EDIT MANUALLY.
# CHANGES WILL BE OVERWRITTEN.
##############################################################################

# AUTO-GENERATED BY SERVICE-TEMPLATE - DO NOT EDIT
"""
Typed HTTP client for backend service.

Features:
- Async context manager for connection lifecycle
- Automatic retry with exponential backoff on transient errors
- Configurable timeout and retry parameters
"""

from __future__ import annotations

import asyncio
from http import HTTPStatus
import logging
import os
from typing import Any

import httpx
from shared.generated.schemas import (
    UserCreate,
    UserRead,
)

LOGGER = logging.getLogger(__name__)


class BackendClient:
    """Async HTTP client for backend service API.

    Features built-in retry with exponential backoff for transient errors:
    - Retries on httpx.ConnectError (service unavailable)
    - Retries on 5xx status codes (server errors)
    - No retry on 4xx client errors (fails immediately)

    Usage:
        async with BackendClient() as client:
            result = await client.create_user(payload)

        # With custom retry settings:
        async with BackendClient(max_retries=5, initial_delay=0.5) as client:
            result = await client.get_user(user_id=123)
    """

    def __init__(
        self,
        base_url: str | None = None,
        timeout: float = 10.0,
        max_retries: int = 3,
        initial_delay: float = 1.0,
    ) -> None:
        """Initialize client.

        Args:
            base_url: Base URL for the service. Defaults to BACKEND_API_URL env var.
            timeout: Request timeout in seconds.
            max_retries: Maximum number of retry attempts for transient errors.
            initial_delay: Initial delay in seconds, doubles each retry (exponential backoff).
        """
        self.base_url = base_url or os.getenv("BACKEND_API_URL", "")
        if not self.base_url:
            raise ValueError(
                "BackendClient requires base_url or BACKEND_API_URL environment variable"
            )
        self.timeout = timeout
        self.max_retries = max_retries
        self.initial_delay = initial_delay
        self._client: httpx.AsyncClient | None = None

    async def __aenter__(self) -> BackendClient:
        """Enter async context manager."""
        self._client = httpx.AsyncClient(
            base_url=self.base_url,
            timeout=self.timeout,
        )
        return self

    async def __aexit__(self, *args: Any) -> None:
        """Exit async context manager."""
        if self._client:
            await self._client.aclose()
            self._client = None

    def _ensure_client(self) -> httpx.AsyncClient:
        """Ensure client is initialized."""
        if self._client is None:
            raise RuntimeError(
                "BackendClient must be used as async context manager: "
                "async with BackendClient() as client: ..."
            )
        return self._client

    async def _request_with_retry(
        self,
        method: str,
        path: str,
        **kwargs: Any,
    ) -> httpx.Response:
        """Execute HTTP request with retry logic for transient errors.

        Implements exponential backoff:
        - Retries on httpx.ConnectError (service unavailable)
        - Retries on 5xx status codes (server errors)
        - No retry on 4xx client errors (fails immediately)

        Args:
            method: HTTP method (get, post, put, delete, etc.)
            path: Request path
            **kwargs: Additional arguments passed to httpx request

        Returns:
            httpx.Response on success

        Raises:
            httpx.HTTPStatusError: On 4xx errors (no retry) or after all retries exhausted
            httpx.ConnectError: After all retries exhausted
        """
        client = self._ensure_client()
        delay = self.initial_delay
        last_exception: Exception | None = None

        for attempt in range(self.max_retries):
            try:
                response = await getattr(client, method)(path, **kwargs)
                response.raise_for_status()
                return response

            except httpx.HTTPStatusError as e:
                status = e.response.status_code

                # 4xx client errors - don't retry, fail immediately
                if HTTPStatus.BAD_REQUEST <= status < HTTPStatus.INTERNAL_SERVER_ERROR:
                    raise

                # 5xx server errors - retry with backoff
                last_exception = e
                if attempt < self.max_retries - 1:
                    LOGGER.warning(
                        "%s returned %s (attempt %d/%d), retrying in %.1fs...",
                        self.base_url,
                        status,
                        attempt + 1,
                        self.max_retries,
                        delay,
                    )
                    await asyncio.sleep(delay)
                    delay *= 2

            except httpx.ConnectError as e:
                last_exception = e
                if attempt < self.max_retries - 1:
                    LOGGER.warning(
                        "%s unavailable (attempt %d/%d), retrying in %.1fs...",
                        self.base_url,
                        attempt + 1,
                        self.max_retries,
                        delay,
                    )
                    await asyncio.sleep(delay)
                    delay *= 2

        # All retries exhausted
        LOGGER.error(
            "Request to %s failed after %d attempts",
            self.base_url,
            self.max_retries,
        )
        if last_exception:
            raise last_exception
        raise RuntimeError("Unexpected retry loop exit")

    # --- users operations ---

    async def create_user(
        self,
        payload: UserCreate,
    ) -> UserRead:
        """Call create_user on backend service."""
        path = "/users"

        response = await self._request_with_retry(
            "post",
            path,
            json=payload.model_dump(mode="json"),
        )
        return UserRead.model_validate(response.json())

    async def get_user(
        self,
        user_id: int,
    ) -> UserRead:
        """Call get_user on backend service."""
        path = f"/users/{user_id}"

        response = await self._request_with_retry(
            "get",
            path,
        )
        return UserRead.model_validate(response.json())
