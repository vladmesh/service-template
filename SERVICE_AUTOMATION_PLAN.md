# План автоматизации добавления сервисов

## 0. Аудит и уточнение требований
1. Зафиксировать текущие ограничения из `AGENTS.md` (работаем только через `make`, inside Docker, compose-проекты не переименовываем).  
2. Проинвентаризировать существующие сервисы (`apps/backend`, `apps/tg_bot`, `apps/frontend`) и их интеграцию в `infra/compose.*.yml`, `Makefile`, `.github/workflows/pr.yml`, чтобы понимать объём последующей миграции.  
3. Собрать список точек, куда новый сервис должен автоматически попадать (лог-команды, тестовые таргеты, compose для dev/unit/integration/prod).  
4. Зафиксировать требования к шаблону (наличие `src/`, `tests/`, `Dockerfile`, `README.md`, `AGENTS.md`) и то, что compose файлы заполняем полностью, а список сервисов для логов/тестов будем генерировать динамически.

## 1. Проектирование шаблона сервиса
1. Создать каталог шаблонов, например `templates/service/default`, и описать структуру: `src/` (с заглушкой `__init__.py`, если тип проекта питон), `tests/` (пустой `__init__.py`, если тип проекта питон), `Dockerfile` с базовыми стадиями, `README.md` пустой, `AGENTS.md` пустой.  
2. Из типов пока default (без py файлов и всего такого) и python.  
3. Добавить документацию по заполнению шаблона в корневой `README.md`/`AGENTS.md`, чтобы разработчики понимали ожидания при ручном редактировании.  
4. При генерации `add_service.sh` создаёт директорию и добавляет в неё нужные файлы из шаблона

## 2. Стандартизация структуры существующих сервисов
1. Для каждого сервиса перенести исходный код в `apps/<service>/src`, оставив корень для инфраструктурных файлов (`Dockerfile`, `README.md`, `AGENTS.md`, конфиги).  
2. Обновить пути импорта/запуска в `Dockerfile`, `pyproject.toml`, `Makefile`-целях и тестах (например, модульные тесты должны ссылаться на `apps.<service>.src`).  
3. Переместить тесты в `apps/<service>/tests` (если уже там, убедиться что структура согласована). Добавить заглушки README/AGENTS, если их нет.  
4. После каждого переноса прогонять `make format`, `make lint`, `make tests backend|tg_bot|integration` для раннего выявления проблем.  
5. Обновить документацию сервисов (их README) с описанием новой структуры.

## 3. Единый источник истины о сервисах
1. Создать файл `services.yml` в корне. Минимальные поля на запись: `name`, `path`, `type`, `description`, `compose` (название сервиса в docker-compose), `logs` (флаги для лог-команд), `tests` (какие таргеты затрагиваются), `dependencies` (опционально).  
2. Заполнить `services.yml` для всех существующих сервисов. Прописать инструкцию, что любые новые сервисы добавляются только через этот файл.  
3. Добавить схему/валидацию (например, скрипт на Python, который проверяет структуру YAML и вызывается в CI).  
4. Описать в AGENTS, что ручные правки сервисов должны сопровождаться обновлением `services.yml`.  
5. Для любых правок файла использовать Python-утилиту (запускаемую из tooling-контейнера), чтобы не полагаться на fragile `sed`/`yq` и упростить наполнение из диалога.

## 4. Обновление docker-compose файлов
1. Определить для каждой среды (`infra/compose.base.yml`, `infra/compose.dev.yml`, `infra/compose.tests.unit.yml`, `infra/compose.tests.integration.yml`, `infra/compose.prod.yml`) единое место для сервисных блоков.  
2. Разработать шаблон блока, который будет вставлять `add_service.sh` (имена сервисов, volumes, env-файлы, build-контекст `apps/<service>`). Предусмотреть параметры (порты, зависимости) из `services.yml`.  
3. Написать вспомогательный скрипт/модуль, который по данным YAML генерирует/обновляет соответствующий блок в compose-файле (чёткие маркеры `# >>> services generated`…`# <<<`).  
4. Прогнать инструмент по текущим сервисам, чтобы compose-файлы стали «истинными» и человекочитаемыми, но при этом автоматически поддерживаемыми.  
5. В `add_service.sh` предусмотреть шаг, который добавляет новую секцию в базовый compose и, если требуется, в dev/tests варианты (на основании флагов из `services.yml`). Проверять корректность синтаксиса `docker compose config`.  
6. Реализация генератора — на Python: отдельный скрипт читает `services.yml` и пересоздаёт compose-блоки; вызывается тем же tooling-контейнером, что и линтеры (проект уже монтируется внутрь).  

## 5. Генерация логов и тестов «на лету»
1. В `Makefile` переписать цели `logs`, `tests <suite>` так, чтобы они динамически получали список сервисов из `services.yml` (через `python -c "..."` или `yq`).  
2. Обновить `.github/workflows/pr.yml`, чтобы матрицы тестов строились на основании того же YAML (использовать `actions/checkout` + `python scripts/services.py matrix`).  
3. Убедиться, что новые цели `make logs <service>`/`make tests <suite>=<service>` автоматически подхватывают свежедобавленную запись без ручного редактирования.  
4. Дополнительно проверить, что команды можно запускать из контейнера (`make tests backend` и т.д.) и что изменения не ломают существующие CI-пайплайны.

## 6. Скрипт `add_service.sh (или py)` + цель в Makefile
1. Вместо CLI сделаем диалог, где скрипт задаёт вопросы и собирает все необходимые поля.  
2. Реализовать скрипт:  
   - проверка, что имя уникально;  
   - копирование шаблона в `apps/<service>`;  
   - добавление записи в `services.yml`;  
   - обновление compose-файлов (через общий генератор);  
   - создание README/AGENTS из полей диалога;  
   - подсказки следующего шага (например, дописать бизнес-логику).  
3. Добавить цель `make add-service` в `Makefile`, которая внутри запускает скрипт в контейнере (по правилам AGENTS).  
4. Написать авто-тесты для скрипта (минимум smoke-тест: добавить временный сервис в tmp-каталог, убедиться, что все файлы созданы).  
5. Прописать инструкции по использованию в корневом `README.md`.

## 7. Документация и коммуникации
1. Обновить корневые `README.md` и `AGENTS.md`, добавив разделы про `services.yml`, шаблон, `add_service.sh`, новые правила для compose и тестов.  
2. Для каждого сервиса обновить локальные `README.md`/`AGENTS.md`, приведя структуру к новой норме и описав, как работать с `src/` и `tests/`.  
3. Добавить раздел в `apps/backend/README.md` (и других сервисах) с инструкцией миграции, если кто-то работает на старых ветках.  
4. Проинформировать команду (например, через CHANGELOG или docs) о новой процедуре, чтобы не было ручных добавлений вне скрипта.

## 8. Финальная валидация
1. Запустить `make format`, `make lint`, `make typecheck`, `make tests` (или более узкие таргеты) чтобы убедиться, что миграция не сломала сборку.  
2. Проверить `docker compose config` для каждой среды после генерации.  
3. Добавить проверки в CI, чтобы `services.yml`, шаблоны и compose оставались синхронизированными (например, `make ensure-services-synced`).  
4. Описать процедуру добавления нового сервиса в README (короткий чеклист).

## 9. Итеративное развитие
1. После внедрения базовой версии отслеживать friction у разработчиков и при необходимости добавлять новые типы шаблонов или параметры в `services.yml`.  
2. Расширить `add_service.sh` возможностью обратной операции (удалить сервис) или генерации сопутствующих ресурсов (Alembic миграции, CI-секреты).  
3. Поддерживать документацию в актуальном состоянии при каждом изменении шаблона или структуры сервисов.

---

## Итерация 0 — аудит и уточнение требований
**Цель:** собрать обязательные вводные, чтобы последующие шаги не опирались на предположения.

1. **Подтвердить рабочие ограничения.** Зафиксировать три ключевых правила из `AGENTS.md`: все действия через `make`, любые команды внутри Docker/Compose, compose-проекты не переопределяем. Добавить эти тезисы в описание новой автоматизации, чтобы будущий скрипт запускался через `make add-service`.
2. **Инвентаризация сервисов:**
   - Backend (`apps/backend`): код лежит в `app/`, `core/`, `main.py` в корне, тесты уже в `tests/`. Нужно отметить, что при миграции всё надо перенести в `src/`.
   - Telegram bot (`apps/tg_bot`): `main.py` и `tests/` в корне, также требует будущего переноса в `src/`.
   - Frontend (`apps/frontend`): содержит `Dockerfile`, `package.json`, `README.md`, отдельной структуры `src/` пока нет.
3. **Карта интеграций:**
   - Compose-файлы: `infra/compose.base.yml` содержит `backend`, `db`, `caddy`, `tg_bot`; `infra/compose.dev.yml` расширяет сетку dev; `infra/compose.tests.unit.yml` описывает контейнеры `backend-tests-unit`, `tg-bot-tests-unit`, `tooling`.
   - Makefile: цели `tests` (жёсткие ветки для `backend`, `tg_bot`, `integration`, `frontend`) и `log` (просто проксирует имя сервиса). Любой переход на YAML должен покрыть эти точки.
   - CI (`.github/workflows/pr.yml`): запускает `make lint` и `make tests` (значит, любые изменения в make-целях автоматически затронут пайплайн).
4. **Список артефактов шаблона:** подтверждено требование, что каждый сервис должен иметь `src/`, `tests/`, `Dockerfile`, `README.md`, `AGENTS.md`. Нужно учитывать, что код может быть не только Python, поэтому шаблон должен быть максимально нейтральным, а конкретные языковые особенности — опциональные надстройки.
5. **Определить владельцев решений:** договориться, кто утверждает структуру `services.yml`, формат docker-compose блоков и в каком репозитории появится каталоги шаблонов (вероятно, `templates/`). Без этого на следующих шагах могут возникнуть блокеры.

**Выходные артефакты итерации:** короткое описание текущего состояния (инвентаризация), зафиксированные требования в `SERVICE_AUTOMATION_PLAN.md` (данный блок), согласование с командой (вне репозитория).

## Итерация 1 — проектирование шаблона сервиса
**Цель:** подготовить набор файлов и правил, которые будут копироваться в новый сервис до включения автоматизации.

1. **Определить размещение шаблонов.** Создан раздел `templates/services/default` и специализация `templates/services/python`. Каждый содержит полный набор файлов и каталоги `src/`, `tests/`.
2. **Сформировать содержимое шаблонов:**
   - Default: пустые каталоги `src/`, `tests` (с `.gitkeep`), общие `Dockerfile`, `README.md`, `AGENTS.md` с указаниями по доработке (см. `templates/services/default`).
   - Python: `src/__init__.py`, `src/app.py`, пример `tests/test_smoke.py`, настроенный `Dockerfile` на `python:3.12-slim`, README и AGENTS (см. `templates/services/python`).
3. **Документировать применимость.** Добавлен `templates/README.md` с описанием существующих шаблонов, требованиями к структуре и инструкциями по добавлению новых типов.
4. **Определить параметры конфигурации.** В шаблонах зарезервированы плейсхолдеры `__SERVICE_NAME__` и комментарии, куда `add_service.sh` сможет подставлять значения (имя сервиса, зависимости). Подстановка будет реализована на следующих шагах.
5. **Проверить совместимость с существующими сервисами.** План миграции остаётся прежним: каждый текущий сервис сможет перейти на структуру `src/` + `tests/`, сохранив свои дополнительные файлы (например, `pyproject.toml`). Это отмечено как prerequisite перед генерацией через скрипт.

**Выходные артефакты итерации:** каталог `templates/` с описанием (`templates/README.md`) и двумя готовыми шаблонами для будущей автоматизации.

## Итерация 2 — стандартизация существующих сервисов
**Цель:** привести текущие микросервисы к целевой структуре (`src/`, `tests/`, инфраструктура в корне), чтобы будущий генератор работал с единообразием.

1. **Backend:** создан `apps/backend/src`, туда перенесены `app/`, `core/`, `main.py`; добавлен `src/__init__.py`. Весь код переведён на относительные импорты, а внешние ссылки (Dockerfile, compose, scripts, alembic, тесты) обновлены на `apps.backend.src.*`.
2. **TG bot:** добавлен `apps/tg_bot/src`, перемещён `main.py`, обновлены Dockerfile и README. Добавлен пакет `src/__init__.py` для дальнейшего расширения.
3. **Frontend:** подготовлен пустой `apps/frontend/src/.gitkeep` для соблюдения структуры (код появится позже).
4. **Валидация:** убедились, что структура соответствует шаблону (код в `src`, тесты остаются в `tests`), а вся инфраструктура (scripts, migrations, Dockerfile) продолжает работать с новыми путями.

**Выходные артефакты итерации:** обновлённая файловая структура всех сервисов, переехавшие исходники и документация, отражённая в этом плане.

## Итерация 3 — единый источник истины о сервисах
**Цель:** зафиксировать данные о микросервисах в одном файле и добавить инструмент, который проверяет их корректность.

1. Создан файл `services.yml` (версия 1) с описанием backend, tg_bot и frontend: имя, отображаемый заголовок, тип шаблона (`python` или `default`), путь, описание, сведения для compose (`base`/`dev` сервисы), лог-таргеты и тестовые контейнеры.
2. Реализован скрипт `scripts/services_registry.py`, который умеет валидировать структуру и выводить список сервисов. Использует PyYAML (уже в зависимостях) и проверяет существование файлов/путей.
3. Добавлена make-цель `make services-validate`, запускающая в tooling-контейнере проверку `services.yml` (описано в `AGENTS.md`).
4. `AGENTS.md` дополнен новой командой, чтобы разработчики знали, как валидировать реестр перед изменениями.

**Выходные артефакты итерации:** `services.yml`, вспомогательный скрипт в `scripts/`, цель `make services-validate`, обновлённый план и AGENTS.

## Итерация 4 — синхронизация docker-compose
**Цель:** перевести compose-файлы на управление через `services.yml`, но оставить итоговые файлы полностью заполненными и читабельными.

1. Созданы шаблоны сервисных блоков (`infra/compose.services/<service>/<target>.yml`) для backend (base/dev) и tg_bot (base). Каждый шаблон описывает полный YAML-фрагмент сервиса.
2. В `infra/compose.base.yml` и `infra/compose.dev.yml` добавлены маркеры `# >>> / # <<<`, обозначающие управляемую зону с сервисами; остальные блоки (db, caddy и т.д.) остаются ручными.
3. Реализован скрипт `scripts/compose_sync.py`, который читает `services.yml`, подбирает нужные шаблоны и перезаписывает участок файла. Вызов: `make compose-sync` (через tooling-контейнер). Команда задокументирована в `AGENTS.md`.
4. `services.yml` расширен полем `compose.templates`, чтобы указать путь к YAML-шаблонам для каждого таргета (`base`, `dev`).

**Выходные артефакты итерации:** папка `infra/compose.services`, скрипт синхронизации, новая make-цель и обновлённые compose-файлы с автомаркерами.

## Итерация 5 — логика логов и тестов из `services.yml`
**Цель:** исключить ручное перечисление сервисов в `make log`/`make tests` и запускать их на основании реестра.

1. В `services.yml` для каждого тестового набора добавлен флаг `mode` (`run` для `docker compose run`, `up` для интеграционных тестов) и заведён отдельный сервис `integration` с описанием общей интеграционной сборки.
2. Скрипт `scripts/services_registry.py` научился:
   - валидировать новые ограничения (`type ∈ {python, default}`, `mode ∈ {run, up}`);
   - выдавать список тестов (`services_registry.py tests [--suite name]`) и лог-таргетов (`services_registry.py logs [--service name]`).
3. Цель `make tests` теперь читает матрицу из `services.yml` (через tooling-контейнер), выводит человекочитаемые подсказки и автоматически выбирает нужный режим запуска (`run`/`up + down`). Это распространяется и на `make tests integration`.
4. Цель `make log` также обращается к реестру, чтобы определить корректное имя сервиса в dev-compose (например, `tg_bot`), и выводит подсказку перед стримом логов.

**Выходные артефакты итерации:** обновлённый `services.yml`, расширенный `scripts/services_registry.py`, динамические цели `make tests` и `make log`, документация в плане.

## Итерация 6 — интерактивный генератор сервисов
**Цель:** предоставить команду `make add-service`, которая через диалог создаёт новый сервис из шаблона и прописывает его во всех нужных местах.

1. Скрипт `scripts/add_service.py` (запускается внутри tooling-контейнера) собирает данные:
   - slug (имя сервиса) и отображаемое название;
   - тип (`python` или `default`), путь (по умолчанию `apps/<slug>`), описание;
   - имена compose-сервисов для base/dev, участие в логах, набор тестов (можно добавить несколько с указанием compose-файла/проект/сервиса/режима `run|up`);
   - содержимое README/AGENTS (вводится в диалоге, многострочно).
2. На основании ввода:
   - копирует шаблон из `templates/services/<type>` в указанный путь (с подстановкой `__SERVICE_NAME__`);
   - записывает README.md и AGENTS.md (если пользователь ввёл текст, иначе оставляет шаблон);
   - создаёт каталог `infra/compose.services/<slug>/` и генерирует `base.yml` (и `dev.yml`, если включён dev-режим) с базовыми настройками build/image/volume;
   - добавляет новый объект в `services.yml` (описание, `compose.services`, `compose.templates`, `logs`, `tests`, `tags`).
3. После генерации скрипт автоматически выполняет `scripts/services_registry.py validate` и `scripts/compose_sync.py`, чтобы убедиться в консистентности и обновить `infra/compose.*.yml`.
4. Добавлена make-цель `make add-service`, которая запускает скрипт в интерактивном режиме внутри tooling-контейнера. AGENTS.md пополнен инструкциями по использованию.

**Выходные артефакты итерации:** `scripts/add_service.py`, make-цель `add-service`, новая документация и полностью автоматизированный поток добавления сервиса.
